/*
 * generated by Xtext 2.17.0
 */
package org.osate.expr.scoping

import com.google.common.collect.Iterables
import com.google.inject.Inject
import java.util.Iterator
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xsemantics.runtime.RuleEnvironment
import org.eclipse.xtext.naming.IQualifiedNameConverter
import org.eclipse.xtext.resource.EObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.FilteringScope
import org.eclipse.xtext.scoping.impl.SimpleScope
import org.osate.aadl2.AbstractFeature
import org.osate.aadl2.Classifier
import org.osate.aadl2.ComponentClassifier
import org.osate.aadl2.ComponentPrototype
import org.osate.aadl2.Feature
import org.osate.aadl2.FeatureGroup
import org.osate.aadl2.FeatureGroupPrototype
import org.osate.aadl2.FeatureGroupType
import org.osate.aadl2.NamedElement
import org.osate.aadl2.Subcomponent
import org.osate.expr.ExprTypeSystem
import org.osate.expr.expr.Block
import org.osate.expr.expr.EDeclaration
import org.osate.expr.expr.ExprLibrary
import org.osate.expr.expr.ExprSubclause
import org.osate.expr.expr.Expression
import org.osate.expr.expr.FunDecl
import org.osate.expr.expr.NamedElementRef
import org.osate.expr.expr.Selection
import org.osate.expr.expr.TypeDecl
import org.osate.expr.expr.TypeRef
import org.osate.xtext.aadl2.properties.scoping.PropertiesScopeProvider

import static org.osate.expr.expr.ExprPackage.Literals.*

import static extension org.eclipse.xtext.EcoreUtil2.*

//import static extension org.eclipse.xtext.EcoreUtil2.*
/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class ExprScopeProvider extends PropertiesScopeProvider {

	@Inject
	ExprTypeSystem typeSystem

	@Inject
	IQualifiedNameConverter qualifiedNameConverter

	override getScope(EObject context, EReference reference) {
		switch reference {
			case SELECTION__REF: {
				val selection = context as Selection
				getSelectionScope(selection.receiver, selection, reference)
			}
			case NAMED_ELEMENT_REF__REF:
				getNamedElementScope(context as NamedElementRef, reference)
			case TYPE_REF__REF:
				getAnnexScope(context, reference)
			default:
				getAnnexScope(context, reference)
		}
	}

	def IScope getAnnexScope(EObject context, EReference reference) {
		switch context {
			FunDecl: {
				val existingScope = Scopes.scopeFor(context.args, getAnnexScope(context.eContainer, reference))
				val thisDecl = context.getContainerOfType(EDeclaration)

				if (thisDecl === null)
					existingScope
				else
					// Scope that filters out the context element from the candidates list
					new FilteringScope(existingScope, [getEObjectOrProxy != thisDecl])
			}
			default: {
				val block = context.getContainerOfType(Block)
				if (block !== null) {
					val annexCandidates = Iterables.filter(block.eContents, NamedElement)
					val existingScope = Scopes.scopeFor(annexCandidates, getAnnexScope(block.eContainer, reference))
					val thisDecl = context.getContainerOfType(EDeclaration)

					if (thisDecl === null)
						existingScope
					else
						// Scope that filters out the context element from the candidates list
						new FilteringScope(existingScope, [getEObjectOrProxy != thisDecl])
				} else {
					val annexCandidates = Iterables.filter(getExprAnnexRoot(context).eContents, NamedElement)
					val existingScope = Scopes.scopeFor(annexCandidates, getClassifierScope(context, reference))
					val thisDecl = context.getContainerOfType(EDeclaration)

					if (thisDecl === null)
						existingScope
					else
						// Scope that filters out the context element from the candidates list
						new FilteringScope(existingScope, [getEObjectOrProxy != thisDecl])
				}
			}
		}
	}

	def <T> iterable(Iterator<T> iter) {
		new Iterable<T>() {
			override iterator() {
				iterator
			}
		}
	}

	def getClassifierScope(EObject context, EReference reference) {
		val classifier = context.getContainerOfType(Classifier)
		val delegateScope = delegateGetScope(context, reference)
		val newDelegateScope = new SimpleScope(delegateScope.allElements.map [
			val name = qualifiedNameConverter.toString(it.name)
			val qname = if (name.startsWith('expr$'))
					qualifiedNameConverter.toQualifiedName(name.substring(5))
				else
					it.name
			EObjectDescription.create(qname, getEObjectOrProxy)
		], true)
		if (classifier === null)
			newDelegateScope
		else
			Scopes.scopeFor(classifier.members, newDelegateScope)
	}

	def getNamedElementScope(NamedElementRef context, EReference reference) {
		if (context.core)
			getClassifierScope(context, reference)
		else
			getAnnexScope(context, reference)
	}

	def getSelectionScope(Expression receiver, Selection context, EReference reference) {
		val prevType = receiver.expressionType
		val namespace = switch prevType {
			// AADL Types
			AbstractFeature:
				switch featureClassifier : prevType.abstractFeatureClassifier {
					ComponentClassifier: featureClassifier
					ComponentPrototype: featureClassifier.constrainingClassifier
					default: prevType.featurePrototype.constrainingClassifier
				}
			FeatureGroup:
				switch featureType : prevType.featureType {
					FeatureGroupType: featureType
					FeatureGroupPrototype: featureType.constrainingFeatureGroupType
				}
			Feature:
				switch featureClassifier : prevType.featureClassifier {
					ComponentClassifier: featureClassifier
					ComponentPrototype: featureClassifier.constrainingClassifier
				}
			Subcomponent:
				switch subcomponentType : prevType.subcomponentType {
					ComponentClassifier: subcomponentType
					ComponentPrototype: subcomponentType.constrainingClassifier
				}
			TypeRef:
				switch ref : prevType.ref {
					TypeDecl: ref.type
					default: ref
				}
			default:
				prevType
		}
		if (namespace === null)
			IScope.NULLSCOPE
		else
			namespace.getAllContentsOfType(NamedElement).scopeFor
	}

	protected def getExpressionType(Expression receiver) {
		typeSystem.type(environmentForExpression(receiver), receiver).getValue()
	}

	private def environmentForExpression(Expression expression) {
		new RuleEnvironment
	}

	def getThisScope(EObject context) {
		val classifier = context.getContainerOfType(Classifier)
		if (classifier === null)
			IScope.NULLSCOPE
		else
			new SimpleScope(
				#[EObjectDescription.create(qualifiedNameConverter.toQualifiedName('this'), classifier)]
			)
	}

	def getExprAnnexRoot(EObject ele) {
		getContainerOfTypes(ele, ExprLibrary, ExprSubclause)
	}

	def EObject getContainerOfTypes(EObject ele, Class<? extends EObject> type1, Class<? extends EObject> type2) {
		for (var e = ele; e !== null; e = e.eContainer())
			if (type1.isInstance(e))
				return type1.cast(e)
			else if (type2.isInstance(e))
				return type2.cast(e)

		null
	}

}
