grammar org.osate.expr.Expr with org.osate.xtext.aadl2.properties.Properties

generate expr "http://www.osate.org/expr/Expr"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://aadl.info/AADL/2.0" as aadl2

// for testing
ExprModel:
	'library' annex=ExprLibrary
	| 'subclause' annex=ExprSubclause
;

ExprLibrary returns aadl2::AnnexLibrary:
	{ExprLibrary} Declarations?
;

ExprSubclause returns aadl2::AnnexSubclause:
	{ExprSubclause} Declarations?
;

NamedElement returns aadl2::NamedElement:
	ExprLibrary | ExprSubclause | EDeclaration
;

fragment Declarations*:
	decls+=EDeclaration (';' decls+=EDeclaration)* ';'?
;

EDeclaration:
	TypeDecl | VarDecl | FunDecl | Assertion
;

TypeDecl:
	'type' name=ID ':' type=Type
;

VarDecl:
	((const?='val') | 'var') name=ID (':' type=Type)? ('=' value=Expression)?
;

FunDecl:
	'def' name=ID '(' ')'
;

Assertion:
	'assert' name=ID ':' assert=Expression
;

// Types

Type:
	PrimitiveType | Category | MetaClass | ClassifierType
	| RecordType | UnionType | TupleType | ListType | SetType | BagType | MapType | TypeRef
;

PrimitiveType:
	{Boolean} 'bool' | {Integer} 'int' | {Real} 'real' | {String} 'string'
;


Category:
	category=ComponentCategory
;

ComponentCategory returns aadl2::ComponentCategory:
	'abstract' | 'bus'| 'data' | 'device' | 'memory' | 'process' | 'processor' | 'subprogram'
	| 'subprogram' 'group' | 'system' | 'thread' 'group' | 'thread' 
	| 'virtual' 'bus' | 'virtual' 'processor'
;

MetaClass:
	class=MetaClassEnum
;

enum MetaClassEnum:
	COMPONENT='component' | SUBCOMPONENT='subcomponent' | FEATURE='feature'
	|CONNECTION='connection' | FLOW='flow' | MODE='mode'
;


enum TargetType: COMPONENT='component'|FEATURE='feature'|CONNECTION='connection'|FLOW='flow'|MODE='mode'|ELEMENT='element'|ROOT='root';


ClassifierType:
	{ClassifierType}
	'classifier' ( 
		'(' base=[aadl2::Classifier|QCREF] ')'
	)?
;

RecordType:
	{RecordType}
	'record' '{'
		field+=Field*
	'}'
;

Field:
	name=ID ':' type=Type ';'
;

UnionType:
	{UnionType}
	'union' '{'
		'???'
	'}'
;

TupleType:
	{TupleType}
	'tuple' '{'
		field+=TupleField*
	'}'
;

TupleField:
	{Field}
	type=Type
;

ListType:
	{ListType}
	'list' 'of' type=Type
;

SetType:
	'set' 'of' type=Type
;

BagType:
	'bag' 'of' type=Type
;

MapType:
	'map' dom=Type '->' img=Type 
;

TypeRef:
	ref=[TypeDecl|QCREF]
;

// Expressions

enum Operation:
	OR='or' | ALT_OR='||'
	| AND='and' | ALT_AND='&&'
	| EQ='==' | NEQ='!='
	| GEQ='>=' | LEQ='<=' | GT='>' | LT='<' | IN='><'
	| PLUS='+' | MINUS='-'
	| MULT='*' | DIV='/' | INTDIV='div' | MOD='mod'
	| NOT='not'
;

Expression returns Expression: 
	OrExpression
;

OrExpression returns Expression:
	AndExpression (=>({BinaryOperation.left=current} operator=OpOr) right=AndExpression)*
;

OpOr returns Operation:
	'or' | '||'
;

AndExpression returns Expression:
	EqualityExpression (=>({BinaryOperation.left=current} operator=OpAnd) right=EqualityExpression)*
;

OpAnd returns Operation:
	'and' | '&&'
;

EqualityExpression returns Expression:
	RelationalExpression (=>({BinaryOperation.left=current} operator=OpEquality) right=RelationalExpression)*
;

OpEquality returns Operation:
	'==' | '!=' 
;

RelationalExpression returns Expression:
//	OtherOperatorExpression
//	( =>({BinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=OtherOperatorExpression)*;
	AdditiveExpression ( =>({BinaryOperation.left=current} operator=OpCompare) right=AdditiveExpression)*
;

OpCompare returns Operation:
	'>=' | '<=' | '>' | '<' | '><'
;

//OtherOperatorExpression returns aadl2::PropertyExpression:
//	AdditiveExpression (=>({ABinaryOperation.leftOperand=current} feature=OpOther)
//	rightOperand=AAdditiveExpression)*;
//
//OpOther:
//	  '->' 
//	| '..<'
//	| '>' '..'
//	| '..'
//	| '=>' 
//	| '>' (=>('>' '>') | '>') 
//	| '<' (=>('<' '<') | '<' | '=>')
//	| '<>'
//	| '?:';

AdditiveExpression returns Expression:
	MultiplicativeExpression (=>({BinaryOperation.left=current} operator=OpAdd) right=MultiplicativeExpression)*
;

OpAdd returns Operation:
	'+' | '-'
;

MultiplicativeExpression returns Expression:
	UnaryOperation (=>({BinaryOperation.left=current} operator=OpMulti) right=UnaryOperation)*
;

OpMulti returns Operation:
	'*' | '/' | 'div' | 'mod'
;

UnaryOperation returns Expression:
	{UnaryOperation} =>operator=OpUnary operand=UnitExpression 
	| UnitExpression
;

OpUnary returns Operation:
	"not" | "-" | "+"
;

UnitExpression returns Expression:
	PrimaryExpression ({UnitExpression.expression=current} (convert?='%' | drop?='in')? unit=[aadl2::UnitLiteral|ID])?
;

PrimaryExpression returns Expression:
	VarRef | ModelOrPropertyReference 
	| FunctionCall | RangeExpression | IfExpression
	| Literal | '(' Expression ')'
;

VarRef:
	ref=[VarDecl|QCREF]
;

// Reference to property, property constant, or model element.
ModelOrPropertyReference returns Expression:
	ModelReference (
		=>({PropertyReference.modelElementReference=current} '#') property=[aadl2::AbstractNamedValue|QPREF]
	)? 
	| PropertyReference
;

ModelReference:
	modelElement=[aadl2::NamedElement|This] (
		{ModelReference.prev=current} '.' modelElement=[aadl2::NamedElement|ID]
	)*
;

// must be a rule, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=318482 
This:
	'this'
;

PropertyReference returns PropertyReference:
	{PropertyReference}'#' property=[aadl2::AbstractNamedValue|QPREF]
;

FunctionCall returns Expression:
	{FunctionCall} function=QCREF '(' (arguments+=Expression (',' arguments+=Expression)*)? ')'
;

RangeExpression returns Expression:
	{Range} '[' minimum=Expression '..' maximum=Expression (=> 'delta' delta=Expression)? ']'
;

IfExpression returns Expression:
	{Conditional} 'if' if=Expression 'then' then=Expression ('else' else=Expression)? 'endif'
;

Literal returns Expression:
	EBooleanLiteral | EIntegerLiteral | ERealLiteral | EStringLiteral
	| ListLiteral | SetLiteral | RecordLiteral | UnionLiteral | TupleLiteral 
	| BagLiteral | MapLiteral 
;

EBooleanLiteral returns Expression :
	{EBool} (value?='true'|'false')
;

EIntegerLiteral returns Expression:
	{EInt} value=INTEGER_LIT
;

ERealLiteral returns Expression:
	{EReal} value=REAL_LIT
;

EStringLiteral returns Expression:
	{EString} value=NoQuoteString
;

fragment CommaSeparatedExpressions*:
	elements+=Expression (',' elements+=Expression)*
;

ListLiteral returns Expression:
	{ListLiteral} 'list' '(' CommaSeparatedExpressions? ')'
;

SetLiteral returns Expression:
	{SetLiteral} 'set' '(' CommaSeparatedExpressions? ')'
;

RecordLiteral returns Expression:
	{RecordLiteral} 'record'
;

UnionLiteral returns Expression:
	{UnionLiteral} 'union'
;

TupleLiteral returns Expression:
	{TupleLiteral} 'tuple' '(' CommaSeparatedExpressions? ')'
;

BagLiteral returns Expression:
	{BagLiteral} 'bag' '(' CommaSeparatedExpressions? ')'
;

MapLiteral returns Expression:
	{MapLiteral} 'map'
;
