grammar org.osate.expr.Expr with org.osate.xtext.aadl2.properties.Properties

generate expr "http://www.osate.org/expr/Expr"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://aadl.info/AADL/2.0" as aadl2

// for testing
ExprModel:
	'library' annex=ExprLibrary
	| 'subclause' annex=ExprSubclause
;

ExprLibrary returns aadl2::AnnexLibrary:
	{ExprLibrary} Declarations?
;

ExprSubclause returns aadl2::AnnexSubclause:
	{ExprSubclause} Declarations?
;


NamedElement returns aadl2::NamedElement:
	ExprLibrary | ExprSubclause | EDeclaration | Argument | Field
;

fragment Declarations*:
	decls+=EDeclaration (';' decls+=EDeclaration)* ';'?
;

EDeclaration:
	TypeDecl | VarDecl | FunDecl | Assertion
;

TypeDecl:
	'type' name=ID /*('extends' baseType=Type)?*/ ':' type=Type
	(
		'{'
		ownedPropertyAssociations+=PropertyAssociation (';' ownedPropertyAssociations+=PropertyAssociation)*
		'}'
	)?
;

VarDecl:
	((const?='val') | 'var') name=ID (':' declType=Type)? ('=' value=Expression)?
;

FunDecl:
	'def' name=ID '(' Args ')' ':' resultType=Type ('=' (java?='java' ':' fqn=JavaFQN | exp=Expression))?
;

JavaFQN:
	ID ('.' ID)*
;

fragment Args*:
	(args+=Argument (',' args+=Argument)*)?
;

Argument:
	{Argument} name=ID ':' type=Type
;

Assertion:
	'assert' name=ID ':' assert=Expression
;

// Types

Type returns aadl2::Type:
	PrimitiveType | RangeType | Category | MetaClass
	| RecordType | UnionType | TupleType | ListType | SetType | BagType | MapType 
	| EnumType | TypeRef
;

PrimitiveType returns aadl2::Type:
	{EBoolean} 'bool' | ENumberType | {EString} 'string'
;

ENumberType:
	EInteger | EReal	
;

EInteger:
	{EInteger} 'int'	
;

EReal:
	{EReal} 'real'	
;

RangeType:
	'range' 'of' type=Type
;

Category:
	category=ComponentCategory
;

ComponentCategory returns aadl2::ComponentCategory:
	'abstract' | 'bus'| 'data' | 'device' | 'memory' | 'process' | 'processor' | 'subprogram'
	| 'subprogram' 'group' | 'system' | 'thread' 'group' | 'thread' 
	| 'virtual' 'bus' | 'virtual' 'processor'
;

// TODO: should support real meta class references
MetaClass:
	class=MetaClassEnum
;

enum MetaClassEnum:
	COMPONENT='component' | FEATURE='feature' | CONNECTION='connection' | FLOW='flow' | MODE='mode'
	| PROPERTY='property'
;


enum TargetType: COMPONENT='component'|FEATURE='feature'|CONNECTION='connection'|FLOW='flow'|MODE='mode'|ELEMENT='element'|ROOT='root';


RecordType:
	{RecordType} 'record' '{'
		(fields+=Field (',' fields+=Field)*)?
	'}'
;

Field:
	{Field} name=ID ':' type=Type
;

UnionType:
	{UnionType} 'union' '{'
		(fields+=Field (',' fields+=Field)*)?
	'}'
;

TupleType:
	{TupleType} 'tuple' '{'
		(fields+=TupleField (',' fields+=TupleField)*)?
	'}'
;

TupleField returns Field:
	type=Type
;

ListType:
	'list' 'of' type=Type
;

SetType:
	'set' 'of' type=Type
;

BagType:
	'bag' 'of' type=Type
;

MapType:
	'map' domain=Type '->' image=Type 
;

EnumType:
	{EnumType} 'enum' '{'
		(literals+=EnumLiteral (',' literals+=EnumLiteral)*)?
	'}'
;

EnumLiteral:
	name=ID
;

TypeRef:
	ref=[aadl2::NamedElement|QCREF]
;

// Expressions

enum Operation:
	OR='or' | ALT_OR='||'
	| AND='and' | ALT_AND='&&'
	| EQ='==' | NEQ='!='
	| GEQ='>=' | LEQ='<=' | GT='>' | LT='<' | IN='><'
	| PLUS='+' | MINUS='-'
	| MULT='*' | DIV='/' | INTDIV='div' | MOD='mod'
	| NOT='not'
;

Expression returns Expression:
	OrExpression
	| BlockExpression
;

BlockExpression returns Expression:
	{Block} '{'
		(decls+=VarDecl ';')*
		result=Expression  
	'}'
;

OrExpression returns Expression:
	AndExpression (=>({BinaryOperation.left=current} operator=OpOr) right=AndExpression)*
;

OpOr returns Operation:
	'or' | '||'
;

AndExpression returns Expression:
	EqualityExpression (=>({BinaryOperation.left=current} operator=OpAnd) right=EqualityExpression)*
;

OpAnd returns Operation:
	'and' | '&&'
;

EqualityExpression returns Expression:
	RelationalExpression (=>({BinaryOperation.left=current} operator=OpEquality) right=RelationalExpression)*
;

OpEquality returns Operation:
	'==' | '!=' 
;

RelationalExpression returns Expression:
//	OtherOperatorExpression
//	( =>({BinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=OtherOperatorExpression)*;
	AdditiveExpression ( =>({BinaryOperation.left=current} operator=OpCompare) right=AdditiveExpression)*
;

OpCompare returns Operation:
	'>=' | '<=' | '>' | '<' | '><'
;

//OtherOperatorExpression returns aadl2::PropertyExpression:
//	AdditiveExpression (=>({ABinaryOperation.leftOperand=current} feature=OpOther)
//	rightOperand=AAdditiveExpression)*;
//
//OpOther:
//	  '->' 
//	| '..<'
//	| '>' '..'
//	| '..'
//	| '=>' 
//	| '>' (=>('>' '>') | '>') 
//	| '<' (=>('<' '<') | '<' | '=>')
//	| '<>'
//	| '?:';

AdditiveExpression returns Expression:
	MultiplicativeExpression (=>({BinaryOperation.left=current} operator=OpAdd) right=MultiplicativeExpression)*
;

OpAdd returns Operation:
	'+' | '-'
;

MultiplicativeExpression returns Expression:
	UnaryOperation (=>({BinaryOperation.left=current} operator=OpMulti) right=UnaryOperation)*
;

OpMulti returns Operation:
	'*' | '/' | 'div' | 'mod'
;

UnaryOperation returns Expression:
	{UnaryOperation} =>operator=OpUnary operand=UnitExpression 
	| UnitExpression
;

OpUnary returns Operation:
	"not" | "-" | "+"
;

UnitExpression returns Expression:
	PropertyExpression ({UnitExpression.expression=current} (convert?='%' | drop?='in')? unit=[aadl2::UnitLiteral|ID])?
;

@Override 
PropertyExpression returns Expression:
	SelectExpression (=>({PropertyExpression.modelElement=current} '#') property=[aadl2::AbstractNamedValue|QPREF])?	
;

SelectExpression returns Expression:
	PrimaryExpression
	=>(
		{Selection.receiver=current} '.' 
		ref=[aadl2::NamedElement|QCREF]
		('(' (args+=Expression (',' args+=Expression)*)? ')')?
	)*
;

PrimaryExpression returns Expression:
	NamedElementRef
	| RangeExpression | IfExpression
	| Literal | '(' Expression ')'
;

NamedElementRef:
	(core?='^')?
	ref=[aadl2::NamedElement|QCREF]
	('(' (args+=Expression (',' args+=Expression)*)? ')')?
;

RangeExpression returns Expression:
	{Range} '[' minimum=Expression '..' maximum=Expression (=> 'delta' delta=Expression)? ']'
;

IfExpression returns Expression:
	{Conditional} 'if' if=Expression 'then' then=Expression ('else' else=Expression)? 'endif'
;

// literal values

Literal:
	EBooleanLiteral | NumberLiteral | EStringLiteral
	| ListLiteral | SetLiteral | RecordLiteral | UnionLiteral | TupleLiteral 
	| BagLiteral | MapLiteral
;

Value:
	Literal | WrappedNamedElement	
;

// dummy rule
WrappedNamedElement:
	{WrappedNamedElement} elem=[aadl2::NamedElement|ID]
;

EBooleanLiteral returns Literal :
	{EBooleanLiteral} (value?='true'|'false')
;

NumberLiteral returns Literal:
	EIntegerLiteral | ERealLiteral
;

EIntegerLiteral returns NumberLiteral:
	{EIntegerLiteral} value=INTVALUE
//	('<'unit=UnitTerm'>')?
;

ERealLiteral returns NumberLiteral:
	{ERealLiteral} value=SignedReal
//	('<'unit=UnitTerm'>')?
;

// use this for value conversion
@Override
SignedReal returns aadl2::Real:
	REAL_LIT
;

EStringLiteral returns Literal:
	{EStringLiteral} value=NoQuoteString
;

fragment ExpressionList*:
	'(' (elements+=Expression (',' elements+=Expression)*)? ')'
;

ListLiteral returns Literal:
	{ListLiteral} 'list' ExpressionList
;

SetLiteral returns Literal:
	{SetLiteral} 'set' ExpressionList
;

RecordLiteral returns Literal:
	{RecordLiteral} 'record' '('
		(fieldValues+=FieldValue (',' fieldValues+=FieldValue)*)?
	')'
;

FieldValue:
	name=ID ':' value=Expression
;

UnionLiteral returns Literal:
	{UnionLiteral} 'union' '('
		fieldValue=FieldValue
	')'
;

TupleLiteral returns Literal:
	{TupleLiteral} 'tuple' ExpressionList
;

BagLiteral returns Literal:
	{BagLiteral} 'bag' ExpressionList
;

MapLiteral returns Literal:
	{MapLiteral} 'map'
;

// units and unit terms

//UnitTerm:
//	Unit (=>({UnitTerm.left=current} operator=OpMulti) right=Unit)*
//;
//
//Unit returns UnitTerm:
//	{Unit} unit=ID 
//	| '(' UnitTerm ')'
//;

@Override 
QCREF:
	(ID '::')* ID (':' ID)?
;
