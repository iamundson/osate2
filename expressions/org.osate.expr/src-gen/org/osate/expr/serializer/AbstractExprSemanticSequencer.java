/*
 * generated by Xtext
 */
package org.osate.expr.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.osate.expr.expr.BagType;
import org.osate.expr.expr.Category;
import org.osate.expr.expr.ExprLibrary;
import org.osate.expr.expr.ExprModel;
import org.osate.expr.expr.ExprPackage;
import org.osate.expr.expr.ExprSubclause;
import org.osate.expr.expr.Field;
import org.osate.expr.expr.FunDecl;
import org.osate.expr.expr.ListType;
import org.osate.expr.expr.MapType;
import org.osate.expr.expr.MetaClass;
import org.osate.expr.expr.Real;
import org.osate.expr.expr.RecordType;
import org.osate.expr.expr.SetType;
import org.osate.expr.expr.TupleType;
import org.osate.expr.expr.TypeDecl;
import org.osate.expr.expr.TypeRef;
import org.osate.expr.expr.UnionType;
import org.osate.expr.expr.VarDecl;
import org.osate.expr.services.ExprGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractExprSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ExprGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ExprPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExprPackage.BAG_TYPE:
				sequence_BagType(context, (BagType) semanticObject); 
				return; 
			case ExprPackage.BOOLEAN:
				sequence_PrimitiveType(context, (org.osate.expr.expr.Boolean) semanticObject); 
				return; 
			case ExprPackage.CATEGORY:
				sequence_Category(context, (Category) semanticObject); 
				return; 
			case ExprPackage.EXPR_LIBRARY:
				sequence_ExprLibrary(context, (ExprLibrary) semanticObject); 
				return; 
			case ExprPackage.EXPR_MODEL:
				sequence_ExprModel(context, (ExprModel) semanticObject); 
				return; 
			case ExprPackage.EXPR_SUBCLAUSE:
				sequence_ExprSubclause(context, (ExprSubclause) semanticObject); 
				return; 
			case ExprPackage.FIELD:
				if (rule == grammarAccess.getFieldRule()) {
					sequence_Field(context, (Field) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTupleFieldRule()) {
					sequence_TupleField(context, (Field) semanticObject); 
					return; 
				}
				else break;
			case ExprPackage.FUN_DECL:
				sequence_FunDecl(context, (FunDecl) semanticObject); 
				return; 
			case ExprPackage.INTEGER:
				sequence_PrimitiveType(context, (org.osate.expr.expr.Integer) semanticObject); 
				return; 
			case ExprPackage.LIST_TYPE:
				sequence_ListType(context, (ListType) semanticObject); 
				return; 
			case ExprPackage.MAP_TYPE:
				sequence_MapType(context, (MapType) semanticObject); 
				return; 
			case ExprPackage.META_CLASS:
				sequence_MetaClass(context, (MetaClass) semanticObject); 
				return; 
			case ExprPackage.REAL:
				sequence_PrimitiveType(context, (Real) semanticObject); 
				return; 
			case ExprPackage.RECORD_TYPE:
				sequence_RecordType(context, (RecordType) semanticObject); 
				return; 
			case ExprPackage.SET_TYPE:
				sequence_SetType(context, (SetType) semanticObject); 
				return; 
			case ExprPackage.STRING:
				sequence_PrimitiveType(context, (org.osate.expr.expr.String) semanticObject); 
				return; 
			case ExprPackage.TUPLE_TYPE:
				sequence_TupleType(context, (TupleType) semanticObject); 
				return; 
			case ExprPackage.TYPE_DECL:
				sequence_TypeDecl(context, (TypeDecl) semanticObject); 
				return; 
			case ExprPackage.TYPE_REF:
				sequence_TypeRef(context, (TypeRef) semanticObject); 
				return; 
			case ExprPackage.UNION_TYPE:
				sequence_UnionType(context, (UnionType) semanticObject); 
				return; 
			case ExprPackage.VAR_DECL:
				sequence_VarDecl(context, (VarDecl) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Type returns BagType
	 *     BagType returns BagType
	 *
	 * Constraint:
	 *     type=Type
	 */
	protected void sequence_BagType(ISerializationContext context, BagType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.BAG_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.BAG_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBagTypeAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Category
	 *     Category returns Category
	 *
	 * Constraint:
	 *     category=CategoryEnum
	 */
	protected void sequence_Category(ISerializationContext context, Category semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.CATEGORY__CATEGORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.CATEGORY__CATEGORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCategoryAccess().getCategoryCategoryEnumEnumRuleCall_0(), semanticObject.getCategory());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExprLibrary returns ExprLibrary
	 *
	 * Constraint:
	 *     decls+=Declaration*
	 */
	protected void sequence_ExprLibrary(ISerializationContext context, ExprLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprModel returns ExprModel
	 *
	 * Constraint:
	 *     (annex=ExprLibrary | annex=ExprSubclause)
	 */
	protected void sequence_ExprModel(ISerializationContext context, ExprModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprSubclause returns ExprSubclause
	 *
	 * Constraint:
	 *     decls+=Declaration*
	 */
	protected void sequence_ExprSubclause(ISerializationContext context, ExprSubclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.FIELD__NAME));
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.FIELD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.FIELD__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns FunDecl
	 *     Declaration returns FunDecl
	 *     FunDecl returns FunDecl
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_FunDecl(ISerializationContext context, FunDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunDeclAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ListType
	 *     ListType returns ListType
	 *
	 * Constraint:
	 *     type=Type
	 */
	protected void sequence_ListType(ISerializationContext context, ListType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.LIST_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.LIST_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListTypeAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns MapType
	 *     MapType returns MapType
	 *
	 * Constraint:
	 *     (dom=Type img=Type)
	 */
	protected void sequence_MapType(ISerializationContext context, MapType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.MAP_TYPE__DOM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.MAP_TYPE__DOM));
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.MAP_TYPE__IMG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.MAP_TYPE__IMG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapTypeAccess().getDomTypeParserRuleCall_2_0(), semanticObject.getDom());
		feeder.accept(grammarAccess.getMapTypeAccess().getImgTypeParserRuleCall_4_0(), semanticObject.getImg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns MetaClass
	 *     MetaClass returns MetaClass
	 *
	 * Constraint:
	 *     class=MetaClassEnum
	 */
	protected void sequence_MetaClass(ISerializationContext context, MetaClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.META_CLASS__CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.META_CLASS__CLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetaClassAccess().getClassMetaClassEnumEnumRuleCall_0(), semanticObject.getClass_());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Boolean
	 *     PrimitiveType returns Boolean
	 *
	 * Constraint:
	 *     {Boolean}
	 */
	protected void sequence_PrimitiveType(ISerializationContext context, org.osate.expr.expr.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Integer
	 *     PrimitiveType returns Integer
	 *
	 * Constraint:
	 *     {Integer}
	 */
	protected void sequence_PrimitiveType(ISerializationContext context, org.osate.expr.expr.Integer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Real
	 *     PrimitiveType returns Real
	 *
	 * Constraint:
	 *     {Real}
	 */
	protected void sequence_PrimitiveType(ISerializationContext context, Real semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns String
	 *     PrimitiveType returns String
	 *
	 * Constraint:
	 *     {String}
	 */
	protected void sequence_PrimitiveType(ISerializationContext context, org.osate.expr.expr.String semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns RecordType
	 *     RecordType returns RecordType
	 *
	 * Constraint:
	 *     field+=Field*
	 */
	protected void sequence_RecordType(ISerializationContext context, RecordType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns SetType
	 *     SetType returns SetType
	 *
	 * Constraint:
	 *     type=Type
	 */
	protected void sequence_SetType(ISerializationContext context, SetType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.SET_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.SET_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetTypeAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TupleField returns Field
	 *
	 * Constraint:
	 *     type=Type
	 */
	protected void sequence_TupleField(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.FIELD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.FIELD__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTupleFieldAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns TupleType
	 *     TupleType returns TupleType
	 *
	 * Constraint:
	 *     field+=TupleField*
	 */
	protected void sequence_TupleType(ISerializationContext context, TupleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns TypeDecl
	 *     Declaration returns TypeDecl
	 *     TypeDecl returns TypeDecl
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_TypeDecl(ISerializationContext context, TypeDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.TYPE_DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.TYPE_DECL__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeDeclAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTypeDeclAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns TypeRef
	 *     TypeRef returns TypeRef
	 *
	 * Constraint:
	 *     ref=[TypeDecl|QCREF]
	 */
	protected void sequence_TypeRef(ISerializationContext context, TypeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExprPackage.Literals.TYPE_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExprPackage.Literals.TYPE_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeRefAccess().getRefTypeDeclQCREFParserRuleCall_0_1(), semanticObject.eGet(ExprPackage.Literals.TYPE_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns UnionType
	 *     UnionType returns UnionType
	 *
	 * Constraint:
	 *     {UnionType}
	 */
	protected void sequence_UnionType(ISerializationContext context, UnionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns VarDecl
	 *     Declaration returns VarDecl
	 *     VarDecl returns VarDecl
	 *
	 * Constraint:
	 *     (const?='val'? name=ID type=Type?)
	 */
	protected void sequence_VarDecl(ISerializationContext context, VarDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
